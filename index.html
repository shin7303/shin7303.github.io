<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <style>
        /* --- 基本的なスタイル --- */
        body {
            font-family: 'Arial', 'Hiragino Sans', 'Meiryo', sans-serif;
            line-height: 1.7; /* 少し行間を調整 */
            margin: 0;
            padding: 0;
            background-color: #f0f0f0; /* 明るいグレー */
            color: #333;
        }

        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
            background-color: #ffffff; /* 白 */
            box-shadow: 0 0 10px rgba(0,0,0,0.05); /* 影を少し薄く */
        }

        header {
            background: #333333; /* ダークグレー */
            color: #f8f9fa;     /* 明るいグレー（ほぼ白） */
            padding: 1.5rem 0;  /* 少し余白調整 */
            text-align: center;
            border-bottom: #555555 3px solid; /* グレーのボーダー */
        }

        header h1 {
            margin: 0;
            font-size: 2.2rem; /* 少しフォントサイズ調整 */
        }

        nav {
            text-align: center;
            padding: 10px 0;
            background: #555555; /* 中間色のグレー */
        }

        nav a {
            color: #f0f0f0; /* 明るいグレー */
            text-decoration: none;
            padding: 10px 20px;
            font-weight: bold;
        }
        nav a:hover {
            background: #444444; /* 少し濃いグレー */
        }

        section {
            padding: 25px 20px; /* 余白調整 */
            margin-bottom: 20px;
            border-bottom: 1px #dddddd solid; /* 薄いグレーのボーダー */
        }
        section:last-child {
            border-bottom: none;
        }

        h2 {
            color: #333333;
            border-bottom: 2px solid #555555; /* グレーのボーダー */
            padding-bottom: 8px;
            margin-top: 0; /* section直下のh2の余白調整 */
        }

        h3 {
            color: #444444;
            margin-top: 30px;
        }
        h4 {
            color: #555555;
            margin-top: 25px;
        }

        /* --- プロジェクト関連のスタイル --- */
        .project {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f9f9f9; /* 非常に明るいグレー */
            border-left: 5px solid #777777; /* グレーのアクセント */
        }

        .project-image {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 15px auto; /* 中央揃え */
            border: 1px solid #cccccc; /* 薄いグレーのボーダー */
            border-radius: 4px;
        }

        .project-details {
            margin-top: 10px;
        }
        .project-details p {
            margin-bottom: 0.5em;
        }
        .project-details strong {
            color: #444;
        }


        /* --- コード表示のスタイル --- */
        pre {
            background-color: #2b2b2b; /* ダークな背景 */
            color: #f0f0f0;     /* 明るいテキストカラー */
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto; /* 横スクロールを可能に */
            font-family: 'Consolas', 'Monaco', 'Courier New', Courier, monospace; /* コード向けフォント */
            font-size: 0.85em; /* 少し小さめ */
            line-height: 1.6;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', Courier, monospace;
        }
        /* インラインコードのスタイル */
        p > code, li > code, span > code {
            background-color: #e0e0e0; /* 明るいグレー */
            padding: 2px 5px;
            border-radius: 3px;
            color: #333333;
        }


        footer {
            text-align: center;
            padding: 20px;
            background: #333333; /* ダークグレー */
            color: #f0f0f0;     /* 明るいグレー */
            margin-top: 30px;
        }

        /* --- レスポンシブ対応（簡易版） --- */
        @media(max-width: 768px){
            .container {
                width: 95%;
            }
            header h1 {
                font-size: 1.8rem;
            }
            nav a {
                display: block;
                padding: 8px;
            }
            .project-image {
                max-width: 90%; /* スマホ表示で少し小さく */
            }
        }

    </style>
</head>
<body>

    <nav>
        <a href="#about">自己紹介</a>
        <a href="#projects">制作物</a>
    </nav>

    <div class="container">
        <section id="about">
            <h2>自己紹介 (About Me)</h2>
            <!-- <img src="images/profile.jpg" alt="プロフィール写真" style="width:150px; height:150px; border-radius:50%; float:left; margin-right:20px;"> -->
            <!-- ↑ プロフィール写真が必要な場合は、この行のコメントを解除し、`images/profile.jpg` をご自身の画像に置き換えてください -->
            <p>
                舞鶴高専 総合システム工学専攻 電気電子工学システムコース 2年 吉岡 晨
            </p>
        </section>

        <section id="projects">
            <h2>制作物 (Projects)</h2>

            <!-- プロジェクト1: 本科4年 -->
            <article class="project">
                <h3>本科4年: タッチタイピング可能な片手日本語入力デバイスの製作</h3>
                <p>
                    日本語入力に特化した片手キーボードを作るには、ホームポジションに置きながら48キー打鍵できる必要があるため、2つのレイヤーを切り替えることができるキー数の多いキーボードを製作しました。
                    筐体はDactyl Manuformを使用しています。
                </p>
                <div class="project-details">
                    <p><strong>マイコン:</strong> ProMicro</p>
                    <p><strong>開発環境:</strong> Arduino IDE</p>
                    <p><strong>使用言語:</strong> Arduino言語 (C++)</p>
                </div>

                <h4>関連画像</h4>
                <img src="images/img1" alt="片手日本語入力デバイスの外観" class="project-image">
                <!-- ↑ images/project_katate_device.png はご自身の画像に置き換えてください -->
                <p style="text-align:center; font-size:0.9em; color:#555;">図1: 製作した片手日本語入力デバイス</p>

                <img src="images/img3" alt="片手日本語入力デバイスのキーレイアウト" class="project-image">
                <!-- ↑ images/project_katate_layout.png はご自身の画像に置き換えてください -->
                <p style="text-align:center; font-size:0.9em; color:#555;">図2: キーレイアウト図</p>

                <h4>プログラムコード (Arduino - ProMicro)</h4>
                <pre><code class="language-cpp">
// #include <Keyboard.h> -> #include <Keyboard.h>

#include <Keyboard.h> 
#include "keydefine.h" 

const int col = 7;
const int row = 6;
const int inputPin[col] = { 3,4,5,6,7,8,9 };
const int outputPin[row] = { 19,18,15,14,16,10 };
int i, j, k, L1State;
bool currentState[row][col] = { 0 };
bool beforeState[row][col] = { 0 };
const int keyMap[row][col] = { { KC_ESC, KC_1, KC_2, KC_3, KC_4, KC_5, KC_MINS},
                               { KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_LBRC},
                               { KC_LCTL, KC_A, KC_S, KC_D, KC_F, KC_G, KC_SCOL},
                               { KC_LSFT, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_GRV},
                               { 00, 00, 00, 54, 55, NONE, KC_BSPC},
                               { 00, 00, 00, 64, 65, KC_SPC, 67} };

const int Layer1[row][col] = { { 11, KC_6, KC_7, KC_8, KC_9, KC_0, KC_EQL},
                               { 21, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_RBRC},
                               { 31, KC_H, KC_J, KC_K, KC_L, KC_SCOL, KC_QUOT},
                               { 41, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_BSLS},
                               { 00, 00, 00, 54, 55, NONE, KC_BSPC},
                               { 00, 00, 00, 64, 65, KC_SPC, 67} };

void setup() {
  for( i = 0; i < row; i++){
    pinMode(outputPin[i],OUTPUT);
  }
  for( i = 0; i < col; i++){
    pinMode(inputPin[i],INPUT_PULLUP);
  }
  for( i = 0; i < col; i++){
    for( j = 0; j < row; j++){
      currentState[i][j] = HIGH;
      beforeState[i][j] = HIGH;
    }
    digitalWrite(inputPin[i],HIGH);
  }
  Serial.begin(9600);
  Keyboard.begin();
}

void loop() {
  for (j = 0; j < row; j++) {
    digitalWrite(outputPin[j], LOW);
    for (k = 0; k < col; k++) {
      currentState[j][k] = digitalRead(inputPin[k]);
      if (currentState[j][k] != beforeState[j][k]) {
        if(currentState[4][5] == LOW){ // このインデックスは実際のレイヤーキーの位置に合わせてください
          L1State = 1;
          Serial.println("↓↓Layer1 ON↓↓");
        } else {
          L1State = 0;
        }
        if (currentState[j][k] == LOW) {
          if(L1State == 1){
            Serial.print("Push:");
            Serial.println(Layer1[j][k]);
            Keyboard.press(Layer1[j][k]);
          } else {
            Serial.print("Push:");
            Serial.println(keyMap[j][k]);
            Keyboard.press(keyMap[j][k]);
          }
        } else {
          if(L1State == 1){
            Serial.print("Release:");
            Serial.println(Layer1[j][k]);
            Keyboard.release(Layer1[j][k]);
          } else {
            Serial.print("Release:");
            Serial.println(keyMap[j][k]);
            Keyboard.release(keyMap[j][k]);
          }
        }
        beforeState[j][k] = currentState[j][k];
      }
    }
    digitalWrite(outputPin[j], HIGH);
    delay(1);
  }
}
</code></pre>
            </article>

            <!-- プロジェクト2: 本科5年 -->
            <article class="project">
                <h3>本科5年: USB接続可能なフリック入力デバイスの開発</h3>
                <p>
                    PCでもフリック入力を行うため、USB接続するだけで使えるデバイスを開発しました。大きさは3.5インチです。
                    ライブラリの互換性の問題でディスプレイや開発環境を変更せざるを得ない状況もありましたが、無事完成しました。
                    フォント表示の関係でローマ字表記となっていますが、入力は問題なく行えます。
                    また、下部のボタンでモード切り替えができ、トラックパッドのように使用することも可能です。
                    GUIの実装やフリック入力、トラックパッドの実装は試行錯誤が多く、やや難しかったです。
                    配線を簡略化するため、KiCADという基板CADを用いて基板を設計し発注しました。
                </p>
                <div class="project-details">
                    <p><strong>マイコン:</strong> Raspberry Pi Pico</p>
                    <p><strong>開発環境:</strong> Arduino IDE</p>
                    <p><strong>使用言語:</strong> Arduino言語 (C++)</p>
                    <p><strong>その他ツール:</strong> KiCAD (基板設計)</p>
                </div>

                <h4>関連画像</h4>
                <img src="images/project_flick_device.png" alt="フリック入力デバイスの外観" class="project-image">
                <!-- ↑ images/project_flick_device.png はご自身の画像に置き換えてください -->
                <p style="text-align:center; font-size:0.9em; color:#555;">図3: 開発したフリック入力デバイス</p>

                <img src="images/project_flick_kicad.png" alt="フリック入力デバイスのKiCAD基板図" class="project-image">
                <!-- ↑ images/project_flick_kicad.png はご自身の画像に置き換えてください -->
                <p style="text-align:center; font-size:0.9em; color:#555;">図4: KiCADで設計した基板</p>

                <h4>プログラムコード (Arduino - Raspberry Pi Pico)</h4>
                <pre><code class="language-cpp">// Flick_and_Trackpad.txt の内容をここに貼り付け
// 以下の内容は Flick_and_Trackpad.txt からコピー＆ペーストしてください
// HTML内で < や > を使う場合は < > にエスケープする必要があります。
// #include <Adafruit_GFX.h> -> #include <Adafruit_GFX.h>

#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include <XPT2046_Touchscreen.h>
#include <SPI.h>
#include "PluggableUSBHID.h" // 実際のファイル構成に合わせてください
#include "USBMouseKeyboard.h" // 実際のファイル構成に合わせてください

USBMouseKeyboard Keyboard;

#define COMMON_SCK  18
#define COMMON_MOSI 19
#define COMMON_MISO 16

#define TOUCH_CS 20
#define TFT_DC  28
#define TFT_CS  17
#define TFT_RST 22

#define MODE_SWITCH_PIN  2  // HIGH入力を検出するピン

XPT2046_Touchscreen ts(TOUCH_CS);
Adafruit_ILI9341 tft = Adafruit_ILI9341(&SPI, TFT_DC, TFT_CS, TFT_RST); // & は & にエスケープ

// フリック入力のボタンの大きさ
#define BUTTON_WIDTH 60
#define BUTTON_HEIGHT 55
// フリック入力のボタンのマージン
#define BUTTON_MARGIN_X 5
#define BUTTON_MARGIN_Y 5

bool buttonState[4][5] = {false};
bool flickTouchProcessed = false;
bool trackpadTouchProcessed = false;
bool trackpadMode = false;

#define SWIPE_MARGIN 10 // フリック入力のタッチからのマージン
#define SENSITIVITY 7 // トラックパッドの感度設定

// キャリブレーション情報
#define CALIBRATION_X_MIN 240
#define CALIBRATION_X_MAX 3700
#define CALIBRATION_Y_MIN 240
#define CALIBRATION_Y_MAX 3700

// スワイプの方向を表す列挙型
enum SwipeDirection {
  NO_SWIPE,
  UP,
  DOWN,
  LEFT,
  RIGHT
};

// ボタンの表示を格納する配列 (一部抜粋)
const char* buttonValues[4][5][5] = {
  {
    {" ", " ", " ", " ", " "},
    {"a", "i", "u", "e", "o"},
    {"ka", "ki", "ku", "ke", "ko"},
    {"sa", "si", "su", "se", "so"},
    {" ", " ", " ", " ", " "}
  },
  // ... (以下略、必要であれば全体を記述)
};

//キーコードを格納する配列 (一部抜粋)
char keycodeValues[4][5][5] = {
  {
    {' ', ' ', ' ', ' ', ' '},
    {'3', 'e', '4', '5', '6'}, //あ行
    {'t', 'g', 'h', ':', 'b'}, //か行
    {'x', 'd', 'r', 'p', 'c'}, //さ行
    {' ', ' ', ' ', ' ', ' '}
  },
  // ... (以下略、必要であれば全体を記述)
};

SwipeDirection getSwipeDirection(int16_t startX, int16_t startY, int16_t endX, int16_t endY) {
  int16_t deltaX = endX - startX;
  int16_t deltaY = endY - startY;

  if (abs(deltaX) > abs(deltaY)) { // > は >
    if (deltaX > SWIPE_MARGIN) {
      return RIGHT;
    } else if (deltaX < -SWIPE_MARGIN) { // < は <
      return LEFT;
    }
  } else {
    if (deltaY > SWIPE_MARGIN) {
      return DOWN;
    } else if (deltaY < -SWIPE_MARGIN) {
      return UP;
    }
  }
  return NO_SWIPE;
}

void drawButton(int row, int col) {
  int buttonX = col * (BUTTON_WIDTH + BUTTON_MARGIN_X);
  int buttonY = row * (BUTTON_HEIGHT + BUTTON_MARGIN_Y);

  tft.fillRect(buttonX, buttonY, BUTTON_WIDTH, BUTTON_HEIGHT, ILI9341_WHITE);
  tft.drawRect(buttonX, buttonY, BUTTON_WIDTH, BUTTON_HEIGHT, ILI9341_BLACK);
  tft.setTextColor(ILI9341_BLACK);
  tft.setCursor(buttonX + 10, buttonY + 20);  
}

TS_Point calibrateTouch(TS_Point rawPoint) {
  int16_t x = map(rawPoint.x, CALIBRATION_X_MIN, CALIBRATION_X_MAX, 0, tft.width());
  int16_t y = map(rawPoint.y, CALIBRATION_Y_MIN, CALIBRATION_Y_MAX, 0, tft.height());
  return TS_Point(x, y, rawPoint.z);
}

void handleFlick() {
  boolean bTouch = ts.touched();
  if (bTouch == true && !flickTouchProcessed) { // && は &&
    flickTouchProcessed = true;
    TS_Point startTouch = ts.getPoint();
    while (ts.touched()) {
      delay(10);
    }
    TS_Point endTouch = ts.getPoint();
    TS_Point calibratedStartTouch = calibrateTouch(startTouch);
    TS_Point calibratedEndTouch = calibrateTouch(endTouch);

    SwipeDirection swipeDirection = getSwipeDirection(
      calibratedStartTouch.x, calibratedStartTouch.y,
      calibratedEndTouch.x, calibratedEndTouch.y
    );

    int row = calibratedStartTouch.y / (BUTTON_HEIGHT + BUTTON_MARGIN_Y);
    int col = calibratedStartTouch.x / (BUTTON_WIDTH + BUTTON_MARGIN_X);

    if (row >= 0 && row < 4 && col >= 0 && col < 5) { // >= は >=, < は <
      drawButton(row, col);
      // ... (switch文以下略、文字入力処理)
    }
  } else if (bTouch == false) {
    flickTouchProcessed = false;
  }
}

void handleTrackpad() {
  // ... (トラックパッド処理、一部省略)
  static TS_Point prevTouchPoint;
  boolean bTouch = ts.touched();
  if (bTouch) {
    TS_Point touchPoint = calibrateTouch(ts.getPoint());
    if (!trackpadTouchProcessed) {
      trackpadTouchProcessed = true;
      prevTouchPoint = touchPoint;
      return;
    }
    int16_t deltaX = SENSITIVITY * (touchPoint.x - prevTouchPoint.x);
    int16_t deltaY = SENSITIVITY * (touchPoint.y - prevTouchPoint.y);
    Keyboard.move(deltaX, deltaY);
    prevTouchPoint = touchPoint;
  } else {
    trackpadTouchProcessed = false;
  }
}

// ... (enterTrackpadMode, enterFlickMode, setup, loop関数はほぼそのままなので省略。必要なら全体を記述)
void setup() {
  Serial.begin(115200);
  // SPI ピン設定 (Mbed specific)
  // arduino::MbedSPI SPI(COMMON_SCK, COMMON_MISO, COMMON_MOSI); // この行は環境依存
  // SPI.begin(); // For standard Arduino SPI

  tft.begin();
  tft.setRotation(1);
  tft.setTextSize(2);
  tft.fillScreen(ILI9341_BLACK);
  ts.begin();
  ts.setRotation(3);
  // ... (初期ボタン描画)
  enterFlickMode(); // 初期モード
}

void loop() {
  bool modeSwitchState = digitalRead(MODE_SWITCH_PIN);
  if (modeSwitchState == HIGH) { // ピン入力検知
    if (!trackpadMode) {
      enterTrackpadMode();
    } else {
      enterFlickMode();
    }
    delay(500); 
  }

  if (trackpadMode) {
    handleTrackpad();
  } else {
    handleFlick();
  }
}
</code></pre>
            </article>

            <!-- プロジェクト3: 専攻科1年 -->
            <article class="project">
                <h3>専攻科1年: Transformerモデルを用いて文脈から推定する感情分析手法の比較</h3>
                <p>
                    テキストデータから感情を抽出する手法の一つである、言語モデルを用いた方法に着目しました。
                    その中でも、特にTransformerベースの複数の言語モデル（BERT, RoBERTa, ELECTRAなど）を使用し、
                    日本語の文脈における感情分析の正答率にどのような違いが現れるかを比較・調査しました。
                </p>
                <p>
                    実験はGoogle Colaboratory上でPythonを用いて行い、準備した学習用データセットを各言語モデルに学習させ、
                    その精度を評価しました。この研究を通じて、モデルの種類や学習方法が感情分析の性能に与える影響について考察を深めました。
                </p>
                <div class="project-details">
                    <p><strong>使用技術:</strong> Python, Transformer (BERT, RoBERTa, ELECTRAなど)</p>
                    <p><strong>開発環境:</strong> Google Colaboratory</p>
                </div>

                <h4>関連画像</h4>
                <img src="images/project_transformer_graph.png" alt="感情分析モデルの性能比較グラフ" class="project-image">
                <!-- ↑ images/project_transformer_graph.png はご自身の画像に置き換えてください -->
                <p style="text-align:center; font-size:0.9em; color:#555;">図5: 各言語モデルの学習ステップごとの正答率比較グラフ（例）</p>

                <!-- このプロジェクトに直接的なコードスニペットがない場合は、GitHubリポジトリへのリンクなどを記載しても良いでしょう -->
                <!--
                <h4>関連リソース</h4>
                <p>詳細なコードや論文は<a href="[GitHubリポジトリへのリンク]" target="_blank">こちらのGitHubリポジトリ</a>で公開予定です。</p>
                -->
            </article>

        </section>

    <footer>
        <p>© 2025 Shin Yoshioka. All Rights Reserved.</p>
    </footer>
</body>
</html>
