<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <!-- Prism.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <!-- 必要であれば、別のテーマを選択してください (例: prism-okaidia.min.css, prism-tomorrow.min.cssなど) -->
    <!-- <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" /> -->

    <style>
        /* --- 基本的なスタイル --- */
        body {
            font-family: 'Arial', 'Hiragino Sans', 'Meiryo', sans-serif;
            line-height: 1.7;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            color: #333;
        }

        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 0 0 10px rgba(0,0,0,0.05);
        }

        /* headerタグは削除されたようなので、関連スタイルはコメントアウトまたは削除も検討 */
        /*
        header {
            background: #333333;
            color: #f8f9fa;
            padding: 1.5rem 0;
            text-align: center;
            border-bottom: #555555 3px solid;
        }

        header h1 {
            margin: 0;
            font-size: 2.2rem;
        }
        */

        nav {
            text-align: center;
            padding: 10px 0;
            background: #555555;
        }

        nav a {
            color: #f0f0f0;
            text-decoration: none;
            padding: 10px 20px;
            font-weight: bold;
        }
        nav a:hover {
            background: #444444;
        }

        section {
            padding: 25px 20px;
            margin-bottom: 20px;
            border-bottom: 1px #dddddd solid;
        }
        section:last-child {
            border-bottom: none;
        }

        h2 {
            color: #333333;
            border-bottom: 2px solid #555555;
            padding-bottom: 8px;
            margin-top: 0;
        }

        h3 {
            color: #444444;
            margin-top: 30px;
        }
        h4 {
            color: #555555;
            margin-top: 25px;
        }

        .project {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-left: 5px solid #777777;
        }

        .project-image {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 15px auto;
            border: 1px solid #cccccc;
            border-radius: 4px;
        }

        .project-details {
            margin-top: 10px;
        }
        .project-details p {
            margin-bottom: 0.5em;
        }
        .project-details strong {
            color: #444;
        }

        /* --- コード表示のスタイル (Prism.jsが適用するが、preの基本スタイルは残す) --- */
        pre[class*="language-"] { /* Prism.jsがこのセレクタを使う */
            background-color: #2b2b2b; /* Prismテーマで上書きされる場合あり */
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.85em;
            line-height: 1.6;
        }
        /* インラインコードのスタイル */
        :not(pre) > code[class*="language-"],
        p > code, li > code, span > code {
            background-color: #e0e0e0;
            padding: 2px 5px;
            border-radius: 3px;
            color: #333333;
            font-family: 'Consolas', 'Monaco', 'Courier New', Courier, monospace;
        }

        footer {
            text-align: center;
            padding: 20px;
            background: #333333;
            color: #f0f0f0;
            margin-top: 30px;
        }

        @media(max-width: 768px){
            .container {
                width: 95%;
            }
            /* header h1のスタイルはheaderタグがないため不要かも */
            nav a {
                display: block;
                padding: 8px;
            }
            .project-image {
                max-width: 90%;
            }
        }
    </style>
</head>
<body>

    <nav>
        <a href="#about">自己紹介</a>
        <a href="#projects">制作物</a>
    </nav>

    <div class="container">
        <section id="about">
            <h2>自己紹介 (About Me)</h2>
            <p>
                舞鶴高専舞鶴工業高等専門学校<br>
                総合システム工学専攻 電気電子工学システムコース 2年<br>
                吉岡 晨
            </p>
        </section>

        <section id="projects">
            <h2>制作物 (Projects)</h2>

            <!-- プロジェクト1: 本科4年 -->
            <article class="project">
                <h3>本科4年: タッチタイピング可能な片手日本語入力デバイスの製作</h3>
                <p>
                    日本語入力に特化した片手キーボードを作るには、ホームポジションに置きながら48キー打鍵できる必要があるため、2つのレイヤーを切り替えることができるキー数の多いキーボードを製作しました。
                    筐体はDactyl Manuformを使用しています。
                </p>
                <div class="project-details">
                    <p><strong>マイコン:</strong> ProMicro</p>
                    <p><strong>開発環境:</strong> Arduino IDE</p>
                    <p><strong>使用言語:</strong> Arduino言語 (C++)</p>
                </div>

                <h4>関連画像</h4>
                <img src="images/img1.jpeg" alt="片手日本語入力デバイスの外観" class="project-image">
                <p style="text-align:center; font-size:0.9em; color:#555;">図1: 製作した片手日本語入力デバイス</p>

                <img src="images/img3.jpeg" alt="片手日本語入力デバイスのキーレイアウト" class="project-image">
                <p style="text-align:center; font-size:0.9em; color:#555;">図2: キーレイアウト図</p>

                <h4>プログラムコード (Arduino - ProMicro)</h4>
                <script src="https://gist.github.com/shin7303/2c3d3e3b2f13448fc88a92d65d973968.js"></script>
            </article>

            <!-- プロジェクト2: 本科5年 -->
            <article class="project">
                <h3>本科5年: USB接続可能なフリック入力デバイスの開発</h3>
                <p>
                    PCでもフリック入力を行うため、USB接続するだけで使えるデバイスを開発しました。大きさは3.5インチです。
                    ライブラリの互換性の問題でディスプレイや開発環境を変更せざるを得ない状況もありましたが、無事完成しました。
                    フォント表示の関係でローマ字表記となっていますが、入力は問題なく行えます。
                    また、下部のボタンでモード切り替えができ、トラックパッドのように使用することも可能です。
                    GUIの実装やフリック入力、トラックパッドの実装は試行錯誤が多く、やや難しかったです。
                    配線を簡略化するため、KiCADという基板CADを用いて基板を設計し発注しました。
                </p>
                <div class="project-details">
                    <p><strong>マイコン:</strong> Raspberry Pi Pico</p>
                    <p><strong>開発環境:</strong> Arduino IDE</p>
                    <p><strong>使用言語:</strong> Arduino言語 (C++)</p>
                    <p><strong>その他ツール:</strong> KiCAD (基板設計)</p>
                </div>

                <h4>関連画像</h4>
                <img src="images/img4.jpeg" alt="フリック入力デバイスの外観" class="project-image">
                <p style="text-align:center; font-size:0.9em; color:#555;">図3: 開発したフリック入力デバイス</p>

                <img src="images/img6.jpeg" alt="フリック入力デバイスのKiCAD基板図" class="project-image">
                <p style="text-align:center; font-size:0.9em; color:#555;">図4: KiCADで設計した基板</p>

                <h4>プログラムコード (Arduino - Raspberry Pi Pico)</h4>
                <pre><code class="language-cpp">
#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include <XPT2046_Touchscreen.h>
#include <SPI.h>
#include "PluggableUSBHID.h"
#include "USBMouseKeyboard.h"

USBMouseKeyboard Keyboard;

#define COMMON_SCK  18
#define COMMON_MOSI 19
#define COMMON_MISO 16

#define TOUCH_CS 20
#define TFT_DC  28
#define TFT_CS  17
#define TFT_RST 22

#define MODE_SWITCH_PIN  2

XPT2046_Touchscreen ts(TOUCH_CS);
Adafruit_ILI9341 tft = Adafruit_ILI9341(&SPI, TFT_DC, TFT_CS, TFT_RST); // & は & にエスケープ

#define BUTTON_WIDTH 60
#define BUTTON_HEIGHT 55
#define BUTTON_MARGIN_X 5
#define BUTTON_MARGIN_Y 5

bool buttonState[4][5] = {false};
bool flickTouchProcessed = false;
bool trackpadTouchProcessed = false;
bool trackpadMode = false;

#define SWIPE_MARGIN 10
#define SENSITIVITY 7

#define CALIBRATION_X_MIN 240
#define CALIBRATION_X_MAX 3700
#define CALIBRATION_Y_MIN 240
#define CALIBRATION_Y_MAX 3700

enum SwipeDirection {
  NO_SWIPE,
  UP,
  DOWN,
  LEFT,
  RIGHT
};

const char* buttonValues[4][5][5] = {
  {
    {" ", " ", " ", " ", " "},
    {"a", "i", "u", "e", "o"},
    {"ka", "ki", "ku", "ke", "ko"},
    {"sa", "si", "su", "se", "so"},
    {" ", " ", " ", " ", " "}
  },
  // 全体を記述する場合はここに追記 (長いため一部省略)
  {
    {" ", " ", " ", " ", " "},
    {"ta", "ti", "tu", "te", "to"},
    {"na", "ni", "nu", "ne", "no"},
    {"ha", "hi", "hu", "he", "ho"},
    {" ", " ", " ", " ", " "}
  },
  {
    {" ", " ", " ", " ", " "},
    {"ma", "mi", "mu", "me", "mo"},
    {"ya", "i", "yu", "e", "yo"},
    {"ra", "ri", "ru", "re", "ro"},
    {" ", " ", " ", " ", " "}
  },
  {
    {" ", " ", " ", " ", " "},
    {" ", " ", " ", " ", " "},
    {"wa", " ", "o", " ", "n"},
    {" ", " ", " ", " ", " "},
    {" ", " ", " ", " ", " "} // 元コードでは "/Users/shin/..." のパスがありましたが、キー定義ではないため空白に修正
  }
};

char keycodeValues[4][5][5] = {
  {
    {' ', ' ', ' ', ' ', ' '},
    {'3', 'e', '4', '5', '6'},
    {'t', 'g', 'h', ':', 'b'},
    {'x', 'd', 'r', 'p', 'c'},
    {' ', ' ', ' ', ' ', ' '}
  },
  // 全体を記述する場合はここに追記 (長いため一部省略)
    {
    {' ', ' ', ' ', ' ', ' '},
    {'q', 'a', 'z', 'w', 's'}, 
    {'u', 'i', '1', ',', 'k'}, 
    {'f', 'v', '2', '^', '-'}, 
    {' ', ' ', ' ', ' ', ' '}
  },
  {
    {' ', ' ', ' ', ' ', ' '},
    {'j', 'n', ']', '/', 'm'}, 
    {'7', 'y', '8', 'y', '9'}, 
    {'o', 'l', '.', ';', ' '}, // 'ro' は単一charではないため暫定で空白。別途処理が必要
    {' ', ' ', ' ', ' ', ' '}
  },
  {
    {' ', ' ', ' ', ' ', ' '},
    {'@', '[', ' ', ' ', ' '}, 
    {'0', ' ', '6', ' ', 'y'}, 
    {' ', ' ', ' ', ' ', ' '},
    {' ', ' ', ' ', ' ', ' '}
  }
};

SwipeDirection getSwipeDirection(int16_t startX, int16_t startY, int16_t endX, int16_t endY) {
  int16_t deltaX = endX - startX;
  int16_t deltaY = endY - startY;

  if (abs(deltaX) > abs(deltaY)) { // > は > にエスケープ
    if (deltaX > SWIPE_MARGIN) { // > は > にエスケープ
      return RIGHT;
    } else if (deltaX < -SWIPE_MARGIN) { // < は < にエスケープ
      return LEFT;
    }
  } else {
    if (deltaY > SWIPE_MARGIN) { // > は > にエスケープ
      return DOWN;
    } else if (deltaY < -SWIPE_MARGIN) { // < は < にエスケープ
      return UP;
    }
  }
  return NO_SWIPE;
}

void drawButton(int row, int col) {
  int buttonX = col * (BUTTON_WIDTH + BUTTON_MARGIN_X);
  int buttonY = row * (BUTTON_HEIGHT + BUTTON_MARGIN_Y);

  tft.fillRect(buttonX, buttonY, BUTTON_WIDTH, BUTTON_HEIGHT, ILI9341_WHITE);
  tft.drawRect(buttonX, buttonY, BUTTON_WIDTH, BUTTON_HEIGHT, ILI9341_BLACK);
  tft.setTextColor(ILI9341_BLACK);
  tft.setCursor(buttonX + 10, buttonY + 20);  
}

TS_Point calibrateTouch(TS_Point rawPoint) {
  int16_t x = map(rawPoint.x, CALIBRATION_X_MIN, CALIBRATION_X_MAX, 0, tft.width());
  int16_t y = map(rawPoint.y, CALIBRATION_Y_MIN, CALIBRATION_Y_MAX, 0, tft.height());
  return TS_Point(x, y, rawPoint.z);
}

void handleFlick() {
  boolean bTouch = ts.touched();
  if (bTouch == true && !flickTouchProcessed) { // && は && にエスケープ
    flickTouchProcessed = true;
    TS_Point startTouch = ts.getPoint();
    while (ts.touched()) {
      delay(10);
    }
    TS_Point endTouch = ts.getPoint();
    TS_Point calibratedStartTouch = calibrateTouch(startTouch);
    TS_Point calibratedEndTouch = calibrateTouch(endTouch);

    SwipeDirection swipeDirection = getSwipeDirection(
      calibratedStartTouch.x, calibratedStartTouch.y,
      calibratedEndTouch.x, calibratedEndTouch.y
    );

    int row = calibratedStartTouch.y / (BUTTON_HEIGHT + BUTTON_MARGIN_Y);
    int col = calibratedStartTouch.x / (BUTTON_WIDTH + BUTTON_MARGIN_X);

    if (row >= 0 && row < 4 && col >= 0 && col < 5) { // >= は >=, < は <, && は && にエスケープ
      drawButton(row, col);
      // switch文以降の Keyboard.printf や Keyboard.key_code_raw の処理はここに記述
      // (元コードのswitch文を参考に、エスケープに注意して記述してください)
      switch (swipeDirection) {
        case LEFT:
          tft.print(buttonValues[row][col][1]);
          Keyboard.printf("%c", keycodeValues[row][col][1]);
          break;
        case UP:
          tft.print(buttonValues[row][col][2]);
          Keyboard.printf("%c", keycodeValues[row][col][2]);
          break;
        case RIGHT:
          tft.print(buttonValues[row][col][3]);          
          Keyboard.printf("%c", keycodeValues[row][col][3]);
          break;
        case DOWN:
          tft.print(buttonValues[row][col][4]);          
          Keyboard.printf("%c", keycodeValues[row][col][4]);
          break;
        case NO_SWIPE:
          tft.print(buttonValues[row][col][0]);          
          if (keycodeValues[row][col][0] == ' ' && keycodeValues[row][col][1] != ' ') { // ' ' との比較、&&は&&
              Keyboard.key_code_raw(0x28);  // Enter想定
          } else if (keycodeValues[row][col][0] != ' ') {
              Keyboard.printf("%c", keycodeValues[row][col][0]);
          }
          break;
        default:
          break;          
      }
    }
  } else if (bTouch == false) {
    flickTouchProcessed = false;
  }
}

void handleTrackpad() {
  static TS_Point prevTouchPoint;
  static unsigned long lastMoveTime = 0; // 元のコードにはありませんでしたが、追加を推奨

  boolean bTouch = ts.touched();
  if (bTouch) {
    TS_Point touchPoint = calibrateTouch(ts.getPoint());
    if (!trackpadTouchProcessed) {
      trackpadTouchProcessed = true;
      prevTouchPoint = touchPoint;
      lastMoveTime = millis(); // 追加
      return;
    }
    int16_t deltaX = SENSITIVITY * (touchPoint.x - prevTouchPoint.x);
    int16_t deltaY = SENSITIVITY * (touchPoint.y - prevTouchPoint.y);
    Keyboard.move(deltaX, deltaY);
    prevTouchPoint = touchPoint;
    lastMoveTime = millis(); // 追加
  } else {
    if (trackpadTouchProcessed && millis() - lastMoveTime > 100) { // &&, > をエスケープ、元コードのロジックを少し修正
        trackpadTouchProcessed = false; // リセット処理
        // prevTouchPoint = TS_Point(0,0,0); // 必要なら
    }
  }
}

void enterTrackpadMode() {
  tft.fillScreen(ILI9341_BLACK);
  trackpadMode = true;
  Serial.println("Entered Trackpad Mode");
}

void enterFlickMode() {
  tft.fillScreen(ILI9341_BLACK);
  trackpadMode = false;
  for (int row = 0; row < 4; row++) { // < をエスケープ
    for (int col = 0; col < 5; col++) { // < をエスケープ
      drawButton(row, col);
      tft.print(buttonValues[row][col][0]);
    }
  }
  Serial.println("Entered Flick Mode");
}

void setup() {
  Serial.begin(115200);
  // SPIピン設定はMbed固有の記述かもしれません。Standard Arduinoでは不要な場合があります。
  // arduino::MbedSPI SPI(COMMON_SCK, COMMON_MISO, COMMON_MOSI);
  // SPI.begin(); // Standard Arduino SPI initialization if needed

  tft.begin();
  tft.setRotation(1);
  tft.setTextSize(2);
  // tft.fillScreen(ILI9341_BLACK); // enterFlickModeで実施
  ts.begin();
  ts.setRotation(3);
  
  pinMode(MODE_SWITCH_PIN, INPUT_PULLUP); // モードスイッチピンを入力プルアップに設定
  
  enterFlickMode(); // 初期モード
}

void loop() {
  bool modeSwitchState = digitalRead(MODE_SWITCH_PIN);

  // ピン入力がLOWになったら（ボタンが押されたら）モード切り替え
  // プルアップしているので、押されたらLOWになります
  static bool lastModeSwitchState = HIGH; // 前回のスイッチの状態
  if (modeSwitchState == LOW && lastModeSwitchState == HIGH) { // && をエスケープ
    if (!trackpadMode) {
      enterTrackpadMode();
    } else {
      enterFlickMode();
    }
    delay(200); // チャタリング防止のための短い待機
  }
  lastModeSwitchState = modeSwitchState;


  if (trackpadMode) {
    handleTrackpad();
  } else {
    handleFlick();
  }
}
</code></pre>
            </article>

            <!-- プロジェクト3: 専攻科1年 -->
            <article class="project">
                <h3>専攻科1年: Transformerモデルを用いて文脈から推定する感情分析手法の比較</h3>
                <p>
                    テキストデータから感情を抽出する手法の一つである、言語モデルを用いた方法の中でも、言語モデルによる正答率の違いを調べた

                </p>
                <p>
                    Google Colab上でPythonを用いて学習用データを3つの言語モデルに学習し、正答率のテストを行った

                </p>
                <div class="project-details">
                    <p><strong>使用技術:</strong> Python, Transformer</p>
                    <p><strong>開発環境:</strong> Google Colaboratory</p>
                </div>

                <h4>関連画像</h4>
                <img src="images/img8.png" alt="感情分析モデルの性能比較グラフ" class="project-image">
                <p style="text-align:center; font-size:0.9em; color:#555;">図5: 各言語モデルの学習ステップごとの正答率比較グラフ</p>
            </article>

        </section>
    </div>

    <footer>
        <p>© 2025 Shin Yoshioka. All Rights Reserved.</p>
    </footer>

    <!-- Prism.js JS (bodyの最後に配置するのが一般的) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <!-- C++言語のハイライトを追加 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <!-- 必要に応じて他の言語も追加できます -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script> -->
</body>
</html>
